# New function to check for stale tickets (no external comments for 7+ days)
# This should be added to the jira-ticket-monitor.yml workflow after the existing monitoring section

# Add this section after the team workload section and before the final curl command

echo "=== Checking for stale tickets (no external comments for 7+ days) ==="

# Create JQL for all open team tickets
STALE_JQL="(${TEAM_MEMBERS_CLAUSE}) AND status NOT IN (Closed, Resolved, Cancelled)"
STALE_JQL_ENCODED=$(urlencode "$STALE_JQL")
STALE_URL="${JIRA_API_URL}?jql=${STALE_JQL_ENCODED}&maxResults=1000&fields=key,summary,assignee,updated,comment,created"
STALE_LINK="${JIRA_BROWSE_URL}${STALE_JQL_ENCODED}"

# Fetch all tickets with comment fields
STALE_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$STALE_URL")

# Initialize stale tickets count and list
STALE_TICKETS=0
STALE_TICKETS_LIST=""
CURRENT_DATE=$(date +%s)
SEVEN_DAYS_IN_SECONDS=$((7 * 24 * 60 * 60))

# Create CSV data variable
CSV_CONTENT="Ticket Key,Summary,Assignee,Created Date,Last External Comment,Days Since Last Comment\n"

# Check if we have tickets
TOTAL_TICKETS=$(jq -r '.total' <<< "$STALE_RESPONSE")

if [ "$TOTAL_TICKETS" -gt 0 ]; then
  # Parse all tickets to check comment history
  ISSUES=$(jq '.issues' <<< "$STALE_RESPONSE")
  
  # Go through each ticket
  ISSUE_COUNT=$(jq '. | length' <<< "$ISSUES")
  
  for (( j=0; j<ISSUE_COUNT; j++ )); do
    ISSUE=$(jq ".[$j]" <<< "$ISSUES")
    
    # Get ticket key and summary
    TICKET_KEY=$(jq -r '.key' <<< "$ISSUE")
    TICKET_SUMMARY=$(jq -r '.fields.summary' <<< "$ISSUE" | sed 's/,/ /g' | sed 's/"//g') # Remove commas and quotes for CSV
    TICKET_ASSIGNEE=$(jq -r '.fields.assignee.displayName' <<< "$ISSUE" | sed 's/,/ /g')
    TICKET_CREATED=$(jq -r '.fields.created' <<< "$ISSUE")
    CREATED_DATE=$(date -d "$TICKET_CREATED" "+%Y-%m-%d")
    
    # Get comment data if it exists
    HAS_COMMENTS=$(jq -r 'if .fields.comment then true else false end' <<< "$ISSUE")
    
    # Default to stale unless we find a recent external comment
    IS_STALE=true
    LAST_EXTERNAL_COMMENT_DATE=""
    LAST_EXTERNAL_COMMENT_EPOCH=0
    
    if [ "$HAS_COMMENTS" = "true" ]; then
      # Get comments array if it exists
      COMMENTS=$(jq -r '.fields.comment.comments' <<< "$ISSUE")
      COMMENTS_COUNT=$(jq '. | length' <<< "$COMMENTS")
      
      # Convert to epoch time for comparison
      for (( k=0; k<COMMENTS_COUNT; k++ )); do
        COMMENT=$(jq ".[$k]" <<< "$COMMENTS")
        
        # Check if this is an external comment (not internal)
        # Internal comments have ".jsdPublic: false" or missing jsdPublic field
        # External comments have "jsdPublic: true"
        IS_INTERNAL=$(jq -r 'if has("jsdPublic") then (if .jsdPublic == false then "true" else "false" end) else "true" end' <<< "$COMMENT")
        
        if [ "$IS_INTERNAL" = "false" ]; then
          # This is an external comment, check its date
          COMMENT_DATE=$(jq -r '.created' <<< "$COMMENT")
          # Convert ISO date to epoch time
          COMMENT_EPOCH=$(date -d "$COMMENT_DATE" +%s)
          
          # Calculate age in seconds
          COMMENT_AGE=$((CURRENT_DATE - COMMENT_EPOCH))
          
          # If comment is newer than 7 days, ticket is not stale
          if [ $COMMENT_AGE -lt $SEVEN_DAYS_IN_SECONDS ]; then
            IS_STALE=false
            break
          fi
          
          # Track the last external comment date
          if [ $COMMENT_EPOCH -gt $LAST_EXTERNAL_COMMENT_EPOCH ]; then
            LAST_EXTERNAL_COMMENT_DATE=$COMMENT_DATE
            LAST_EXTERNAL_COMMENT_EPOCH=$COMMENT_EPOCH
          fi
        fi
      done
    fi
    
    # If the ticket is stale, add it to our list
    if [ "$IS_STALE" = "true" ]; then
      # Format last comment date if available
      COMMENT_DATE_INFO=""
      FORMATTED_DATE="No external comments"
      DAYS_SINCE_COMMENT="N/A"
      
      if [ -n "$LAST_EXTERNAL_COMMENT_DATE" ]; then
        # Convert to more readable format
        FORMATTED_DATE=$(date -d "$LAST_EXTERNAL_COMMENT_DATE" "+%Y-%m-%d")
        
        # Calculate days since last comment
        COMMENT_AGE_DAYS=$(( (CURRENT_DATE - LAST_EXTERNAL_COMMENT_EPOCH) / 86400 ))
        DAYS_SINCE_COMMENT="$COMMENT_AGE_DAYS days"
        
        COMMENT_DATE_INFO=" (Last external comment: $FORMATTED_DATE, $DAYS_SINCE_COMMENT ago)"
      else
        COMMENT_DATE_INFO=" (No external comments found)"
      fi
      
      # Add to the stale tickets list for Slack message (limited to 5)
      STALE_TICKETS=$((STALE_TICKETS + 1))
      if [ $STALE_TICKETS -le 5 ]; then
        STALE_TICKETS_LIST="${STALE_TICKETS_LIST}\n• <${JIRA_BASE_URL}/browse/${TICKET_KEY}|${TICKET_KEY}> - ${TICKET_ASSIGNEE}${COMMENT_DATE_INFO}"
      fi
      
      # Add to CSV content regardless of count
      CSV_CONTENT="${CSV_CONTENT}${TICKET_KEY},\"${TICKET_SUMMARY}\",${TICKET_ASSIGNEE},${CREATED_DATE},${FORMATTED_DATE},${DAYS_SINCE_COMMENT}\n"
    fi
  done
fi

# Create stale tickets message
if [ $STALE_TICKETS -gt 0 ]; then
  # Generate CSV file if more than 5 stale tickets
  if [ $STALE_TICKETS -gt 5 ]; then
    # Generate a filename with date
    CSV_FILENAME="stale_tickets_$(date +%Y-%m-%d).csv"
    echo -e "$CSV_CONTENT" > "$CSV_FILENAME"
    
    # Create GitHub gist for the CSV
    if command -v gh &> /dev/null; then
      echo "Creating GitHub gist for CSV file..."
      GIST_URL=$(gh gist create --public "$CSV_FILENAME" | head -n 1)
      CSV_LINK=" <${GIST_URL}|Download CSV with all ${STALE_TICKETS} tickets>"
    else
      CSV_LINK=" (CSV file generated but GitHub CLI not available to create shareable link)"
    fi
    
    STALE_MESSAGE="⚠️ *Stale Tickets Alert* ⚠️\n\n*${STALE_TICKETS} tickets have no external comments in 7+ days.*\n\nShowing first 5 tickets:${STALE_TICKETS_LIST}\n\n${CSV_LINK}\n\nPlease review these tickets and update with appropriate external comments."
  else
    STALE_MESSAGE="⚠️ *Stale Tickets Alert* ⚠️\n\n*${STALE_TICKETS} tickets have no external comments in 7+ days:*${STALE_TICKETS_LIST}\n\nPlease review these tickets and update with appropriate external comments."
  fi
  
  echo "Sending stale tickets message to Slack..."
  ESCAPED_STALE=$(echo "$STALE_MESSAGE" | sed 's/"/\\"/g')
  curl -s -X POST \
       -H "Content-type: application/json" \
       --data "{\"text\":\"$ESCAPED_STALE\"}" \
       ${{ secrets.SLACK_WEBHOOK_URL }}
  
  # If we can't create a gist but have more than 5 tickets, try to upload the CSV as a Slack file
  if [ $STALE_TICKETS -gt 5 ] && ! command -v gh &> /dev/null; then
    echo "Uploading CSV file to Slack..."
    curl -F file=@"$CSV_FILENAME" \
         -F "initial_comment=Stale tickets CSV export" \
         -F channels=${{ secrets.SLACK_CHANNEL_ID }} \
         -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" \
         https://slack.com/api/files.upload
  fi
else
  echo "No stale tickets found. Skipping stale ticket alert."
fi