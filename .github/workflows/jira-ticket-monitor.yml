name: jira-ticket-monitor

on:
  schedule:
    - cron: '30 4 * * 1-5'
  workflow_dispatch:
  push:
    paths:
      - '.github/workflows/jira-ticket-monitor.yml'

concurrency:
  group: jira-ticket-monitor
  cancel-in-progress: true

env:
  TZ: 'Asia/Kolkata'

jobs:
  monitor-jira-tickets:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Check environment
        run: |
          echo "Runner: $RUNNER_OS"
          echo "Free space:"
          df -h
          echo "Memory info:"
          free -h
            
      - name: Monitor JIRA Tickets
        id: jira-monitor
        run: |
          # Debug: Print version info
          echo "===== RUNNING JIRA MONITOR SCRIPT ====="
          echo "Version: Improved JQL Stale Detection with External Comment Filtering - Sateesh Only"
          
          # Create URL encoding function
          urlencode() {
            local string="${1}"
            local strlen=${#string}
            local encoded=""
            local pos c o
            
            for (( pos=0 ; pos<strlen ; pos++ )); do
              c=${string:$pos:1}
              case "$c" in
                [-_.~a-zA-Z0-9] ) o="${c}" ;;
                * ) printf -v o '%%%02x' "'$c"
              esac
              encoded+="${o}"
            done
            echo "${encoded}"
          }
          
          # JIRA Base URL for API and hyperlinks
          JIRA_BASE_URL="https://quantium.atlassian.net"
          JIRA_API_URL="${JIRA_BASE_URL}/rest/api/3/search"
          JIRA_BROWSE_URL="${JIRA_BASE_URL}/issues/?jql="
          
          # Jira API credentials
          AUTH_HEADER="Authorization: Basic ${{ secrets.JIRA_API_TOKEN }}"
          ACCEPT_HEADER="Accept: application/json"
          
          # Only Sateesh Gulivindala for this test
          MEMBER="Sateesh Gulivindala"
          echo "Monitoring tickets for: $MEMBER"
          
          # We've identified customfield_10065 as having the correct priority values
          PRIORITY_FIELD="customfield_10065"
          echo "Using PRIORITY_FIELD=$PRIORITY_FIELD for priorities"
          
          # Based on findings, define priorities as found in JIRA
          PRIORITY_NAMES=("1 - Critical" "2 - High" "3 - Medium" "4 - Low" "5 - Very Low")
          PRIORITY_SHORT=("P1" "P2" "P3" "P4" "P5")
          
          # Age categories without emojis
          AGE_CATEGORIES=("‚â§7 days" "8-30 days" ">30 days")
          
          # Variables for tracking tickets
          TOTAL_OPEN_TICKETS=0
          PRIORITY_COUNTS=()
          for i in {0..4}; do
            PRIORITY_COUNTS[$i]=0
          done
          UNDEFINED_PRIORITY_COUNT=0
          
          # Time in IST and Sydney
          IST_TIME=$(date +"%I:%M %p IST")
          IST_DATE=$(date +"%d-%m-%Y")
          SYDNEY_TIME=$(TZ='Australia/Sydney' date +"%I:%M %p AEDT")
          
          # Build header part
          HEADER="üìä *JIRA Monitor (Sateesh Only)*"
          
          # Create team-wide JQL for all tickets
          ALL_TEAM_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled)"
          ALL_TEAM_LINK="${JIRA_BROWSE_URL}$(urlencode "$ALL_TEAM_JQL")"
          
          # First query: All open tickets using the standard format
          ALL_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled)"
          ALL_JQL_ENCODED=$(urlencode "$ALL_JQL")
          ALL_URL="${JIRA_API_URL}?jql=${ALL_JQL_ENCODED}&maxResults=1000&fields=${PRIORITY_FIELD},summary,created,updated"
          ALL_LINK="${JIRA_BROWSE_URL}${ALL_JQL_ENCODED}"
          
          # Fetch all tickets with the priority field
          echo "Fetching tickets for $MEMBER..."
          ALL_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$ALL_URL")
          
          # Check for API errors
          if echo "$ALL_RESPONSE" | jq -e '.errorMessages' > /dev/null; then
            API_ERROR=$(echo "$ALL_RESPONSE" | jq -r '.errorMessages[0]')
            echo "ERROR: JIRA API returned an error: $API_ERROR"
            exit 1
          fi
          
          # Extract total count
          TOTAL_COUNT=$(jq -r '.total' <<< "$ALL_RESPONSE")
          TOTAL_OPEN_TICKETS=$TOTAL_COUNT
          echo "Found $TOTAL_COUNT total tickets"
          
          # Initialize counts
          MEMBER_PRIORITY_COUNTS=()
          for i in {0..4}; do
            MEMBER_PRIORITY_COUNTS[$i]=0
          done
          MEMBER_UNDEFINED_COUNT=0
          
          if [ "$TOTAL_COUNT" -gt 0 ]; then
            # Parse all tickets to count priorities
            ISSUES=$(jq '.issues' <<< "$ALL_RESPONSE")
            
            # Go through each ticket and examine its priority value
            ISSUE_COUNT=$(jq '. | length' <<< "$ISSUES")
            
            for (( j=0; j<ISSUE_COUNT; j++ )); do
              ISSUE=$(jq ".[$j]" <<< "$ISSUES")
              TICKET_KEY=$(jq -r '.key' <<< "$ISSUE")
              
              # Get the priority value from the nested JSON directly
              PRIORITY_VALUE=$(jq -r ".fields.\"$PRIORITY_FIELD\".value // \"Unknown\"" <<< "$ISSUE")
              
              # Debug the priority value to help diagnose issues
              echo "  Ticket: $TICKET_KEY | Priority Value: '$PRIORITY_VALUE'"
              
              # Count based on the exact priority value pattern
              if [[ "$PRIORITY_VALUE" == "1 - Critical" ]]; then
                MEMBER_PRIORITY_COUNTS[0]=$((MEMBER_PRIORITY_COUNTS[0] + 1))
                PRIORITY_COUNTS[0]=$((PRIORITY_COUNTS[0] + 1))
              elif [[ "$PRIORITY_VALUE" == "2 - High" ]]; then
                MEMBER_PRIORITY_COUNTS[1]=$((MEMBER_PRIORITY_COUNTS[1] + 1))
                PRIORITY_COUNTS[1]=$((PRIORITY_COUNTS[1] + 1))
              elif [[ "$PRIORITY_VALUE" == "3 - Medium" ]]; then
                MEMBER_PRIORITY_COUNTS[2]=$((MEMBER_PRIORITY_COUNTS[2] + 1))
                PRIORITY_COUNTS[2]=$((PRIORITY_COUNTS[2] + 1))
              elif [[ "$PRIORITY_VALUE" == "4 - Low" ]]; then
                MEMBER_PRIORITY_COUNTS[3]=$((MEMBER_PRIORITY_COUNTS[3] + 1))
                PRIORITY_COUNTS[3]=$((PRIORITY_COUNTS[3] + 1))
              elif [[ "$PRIORITY_VALUE" == "5 - Very Low" ]]; then
                MEMBER_PRIORITY_COUNTS[4]=$((MEMBER_PRIORITY_COUNTS[4] + 1))
                PRIORITY_COUNTS[4]=$((PRIORITY_COUNTS[4] + 1))
              else
                # Default to P3 if unknown, but also track undefined separately
                MEMBER_PRIORITY_COUNTS[2]=$((MEMBER_PRIORITY_COUNTS[2] + 1))
                PRIORITY_COUNTS[2]=$((PRIORITY_COUNTS[2] + 1))
                
                # Increment undefined counters
                MEMBER_UNDEFINED_COUNT=$((MEMBER_UNDEFINED_COUNT + 1))
                UNDEFINED_PRIORITY_COUNT=$((UNDEFINED_PRIORITY_COUNT + 1))
                
                echo "  NOTE: Ticket with undefined priority counted as P3: $TICKET_KEY"
              fi
            done
            
            # Format age breakdown
            WEEK_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND created >= -7d"
            WEEK_JQL_ENCODED=$(urlencode "$WEEK_JQL")
            WEEK_LINK="${JIRA_BROWSE_URL}${WEEK_JQL_ENCODED}"
            WEEK_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "${JIRA_API_URL}?jql=${WEEK_JQL_ENCODED}&maxResults=0")
            WEEK_COUNT=$(jq -r '.total' <<< "$WEEK_RESPONSE")
            
            MONTH_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND created < -7d AND created >= -30d"
            MONTH_JQL_ENCODED=$(urlencode "$MONTH_JQL")
            MONTH_LINK="${JIRA_BROWSE_URL}${MONTH_JQL_ENCODED}"
            MONTH_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "${JIRA_API_URL}?jql=${MONTH_JQL_ENCODED}&maxResults=0")
            MONTH_COUNT=$(jq -r '.total' <<< "$MONTH_RESPONSE")
            
            OLDER_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND created < -30d"
            OLDER_JQL_ENCODED=$(urlencode "$OLDER_JQL")
            OLDER_LINK="${JIRA_BROWSE_URL}${OLDER_JQL_ENCODED}"
            OLDER_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "${JIRA_API_URL}?jql=${OLDER_JQL_ENCODED}&maxResults=0")
            OLDER_COUNT=$(jq -r '.total' <<< "$OLDER_RESPONSE")
            
            # Format message for Sateesh
            MEMBER_MESSAGE="‚Ä¢ *${MEMBER}:* <${ALL_LINK}|${TOTAL_COUNT}>"
            MEMBER_MESSAGE="${MEMBER_MESSAGE}\n  ‚Ü≥ Priority: "
            
            for i in {0..4}; do
              if [ $i -gt 0 ]; then
                MEMBER_MESSAGE="${MEMBER_MESSAGE} | "
              fi
              
              if [ ${MEMBER_PRIORITY_COUNTS[$i]} -gt 0 ]; then
                MEMBER_MESSAGE="${MEMBER_MESSAGE}${PRIORITY_SHORT[$i]}: ${MEMBER_PRIORITY_COUNTS[$i]}"
              else
                MEMBER_MESSAGE="${MEMBER_MESSAGE}${PRIORITY_SHORT[$i]}: ${MEMBER_PRIORITY_COUNTS[$i]}"
              fi
            done
            
            # Add age breakdown to the message
            MEMBER_MESSAGE="${MEMBER_MESSAGE}\n  ‚Ü≥ Age: "
            
            if [ "$WEEK_COUNT" -gt 0 ]; then
              MEMBER_MESSAGE="${MEMBER_MESSAGE}<${WEEK_LINK}|${WEEK_COUNT}> (‚â§7d)"
            else
              MEMBER_MESSAGE="${MEMBER_MESSAGE}${WEEK_COUNT} (‚â§7d)"
            fi
            
            MEMBER_MESSAGE="${MEMBER_MESSAGE} | "
            
            if [ "$MONTH_COUNT" -gt 0 ]; then
              MEMBER_MESSAGE="${MEMBER_MESSAGE}<${MONTH_LINK}|${MONTH_COUNT}> (8-30d)"
            else
              MEMBER_MESSAGE="${MEMBER_MESSAGE}${MONTH_COUNT} (8-30d)"
            fi
            
            MEMBER_MESSAGE="${MEMBER_MESSAGE} | "
            
            if [ "$OLDER_COUNT" -gt 0 ]; then
              MEMBER_MESSAGE="${MEMBER_MESSAGE}<${OLDER_LINK}|${OLDER_COUNT}> (>30d)"
            else
              MEMBER_MESSAGE="${MEMBER_MESSAGE}${OLDER_COUNT} (>30d)"
            fi
          else
            # No tickets for Sateesh
            MEMBER_MESSAGE="‚Ä¢ *${MEMBER}:* 0"
          fi
          
          # Fix the age legend hyperlinks
          TEAM_WEEK_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND created >= -7d"
          TEAM_WEEK_LINK="${JIRA_BROWSE_URL}$(urlencode "$TEAM_WEEK_JQL")"
          
          TEAM_MONTH_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND created < -7d AND created >= -30d"
          TEAM_MONTH_LINK="${JIRA_BROWSE_URL}$(urlencode "$TEAM_MONTH_JQL")"
          
          TEAM_OLDER_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND created < -30d"
          TEAM_OLDER_LINK="${JIRA_BROWSE_URL}$(urlencode "$TEAM_OLDER_JQL")"
          
          # Build the summary message
          SUMMARY_MESSAGE="$HEADER\n\n*Summary:*"
          
          # Plain text summary with hyperlink for total tickets and time zones
          SUMMARY_MESSAGE="$SUMMARY_MESSAGE\n‚Ä¢ *JIRA Status Update* ($SYDNEY_TIME / $IST_TIME)"
          SUMMARY_MESSAGE="$SUMMARY_MESSAGE\n‚Ä¢ *Open Tickets:* <${ALL_TEAM_LINK}|${TOTAL_OPEN_TICKETS}>"
          
          # Add priority breakdown with hyperlinks to specific priority searches
          PRIORITY_SUMMARY="\n‚Ä¢ *Priority Breakdown:* "
          for i in {0..4}; do
            if [ $i -gt 0 ]; then
              PRIORITY_SUMMARY="${PRIORITY_SUMMARY} | "
            fi
            if [ ${PRIORITY_COUNTS[$i]} -gt 0 ]; then
              PRIORITY_SUMMARY="${PRIORITY_SUMMARY}${PRIORITY_SHORT[$i]}: ${PRIORITY_COUNTS[$i]}"
            else
              PRIORITY_SUMMARY="${PRIORITY_SUMMARY}${PRIORITY_SHORT[$i]}: ${PRIORITY_COUNTS[$i]}"
            fi
          done
          
          SUMMARY_MESSAGE="$SUMMARY_MESSAGE$PRIORITY_SUMMARY"
          
          # Create age legend
          AGE_LEGEND="üìä *Legend:* <${TEAM_WEEK_LINK}|‚â§7 days> | <${TEAM_MONTH_LINK}|8-30 days> | <${TEAM_OLDER_LINK}|30+ days>"
          
          # Create one group for legend and notes
          LEGEND_GROUP="$AGE_LEGEND"
          
          # Add note about undefined priorities to the same group
          if [ ${UNDEFINED_PRIORITY_COUNT} -gt 0 ]; then
            LEGEND_GROUP="$LEGEND_GROUP\n\n‚ö†Ô∏è *Note:* Undefined priorities (${UNDEFINED_PRIORITY_COUNT}) are counted under P3."
          fi
          
          # Add the grouped legend to summary message
          SUMMARY_MESSAGE="$SUMMARY_MESSAGE\n\n$LEGEND_GROUP"
          
          echo "Sending summary message to Slack..."
          
          # Send the summary message first
          ESCAPED_SUMMARY=$(echo "$SUMMARY_MESSAGE" | sed 's/"/\\"/g')
          curl -s -X POST \
            -H "Content-type: application/json" \
            --data "{\"text\":\"$ESCAPED_SUMMARY\"}" \
            ${{ secrets.SLACK_WEBHOOK_URL }}
          
          # Sleep to ensure messages are sent in order
          sleep 1
          
          # Send workload message for Sateesh
          WORKLOAD_MESSAGE="*Workload for ${MEMBER}:*\n${MEMBER_MESSAGE}"
          
          echo "Sending workload message to Slack..."
          ESCAPED_WORKLOAD=$(echo "$WORKLOAD_MESSAGE" | sed 's/"/\\"/g')
          curl -s -X POST \
            -H "Content-type: application/json" \
            --data "{\"text\":\"$ESCAPED_WORKLOAD\"}" \
            ${{ secrets.SLACK_WEBHOOK_URL }}
          
          sleep 1
          
          # NEW: Enhanced stale ticket detection with external comment filtering
          echo "Analyzing stale tickets with external comment filtering..."
          
          # Step 1: Get all potentially stale tickets using JQL
          echo "Fetching potentially stale tickets..."
          STALE_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND updated < -7d ORDER BY key ASC"
          STALE_JQL_ENCODED=$(urlencode "$STALE_JQL")
          STALE_URL="${JIRA_API_URL}?jql=${STALE_JQL_ENCODED}&maxResults=100&fields=key,summary,created,updated"
          STALE_LINK="${JIRA_BROWSE_URL}${STALE_JQL_ENCODED}"
          
          STALE_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$STALE_URL")
          
          # Check if the query was successful
          if echo "$STALE_RESPONSE" | jq -e '.errorMessages' > /dev/null; then
            echo "Warning: Standard stale JQL failed, trying alternative syntax..."
            STALE_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND updatedDate < -7d ORDER BY key ASC"
            STALE_JQL_ENCODED=$(urlencode "$STALE_JQL")
            STALE_URL="${JIRA_API_URL}?jql=${STALE_JQL_ENCODED}&maxResults=100&fields=key,summary,created,updated"
            STALE_LINK="${JIRA_BROWSE_URL}${STALE_JQL_ENCODED}"
            
            STALE_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$STALE_URL")
            
            if echo "$STALE_RESPONSE" | jq -e '.errorMessages' > /dev/null; then
              API_ERROR=$(echo "$STALE_RESPONSE" | jq -r '.errorMessages[0]')
              echo "ERROR: JIRA API returned an error for stale ticket query: $API_ERROR"
              
              # Create a simple message in case of error
              STALE_MESSAGE="*Stale Ticket Analysis for ${MEMBER}:*\n"
              STALE_MESSAGE="${STALE_MESSAGE}‚Ä¢ Unable to retrieve stale ticket information due to JQL error: $API_ERROR\n"
              
              # Send to Slack
              ESCAPED_STALE=$(echo "$STALE_MESSAGE" | sed 's/"/\\"/g')
              curl -s -X POST \
                -H "Content-type: application/json" \
                --data "{\"text\":\"$ESCAPED_STALE\"}" \
                ${{ secrets.SLACK_WEBHOOK_URL }}
                
              echo "=== JIRA MONITOR COMPLETED WITH ERRORS ==="
              exit 1
            fi
          fi
          
          # Extract ticket keys and get ticket count
          TICKET_KEYS=($(echo "$STALE_RESPONSE" | jq -r '.issues[].key'))
          TICKET_COUNT=${#TICKET_KEYS[@]}
          
          echo "Found $TICKET_COUNT potentially stale tickets"
          
          # If no tickets found, create a simple report
          if [ $TICKET_COUNT -eq 0 ]; then
            echo "No stale tickets to process"
            
            # Create a message for Slack
            STALE_MESSAGE="*Stale Ticket Analysis for ${MEMBER}:*\n"
            STALE_MESSAGE="${STALE_MESSAGE}‚Ä¢ *Potentially Stale Tickets:* 0 tickets not updated in the last 7 days\n"
            STALE_MESSAGE="${STALE_MESSAGE}‚Ä¢ *Tickets With No External Comments:* 0 tickets have no external comments\n"
            
            # Send to Slack
            ESCAPED_STALE=$(echo "$STALE_MESSAGE" | sed 's/"/\\"/g')
            curl -s -X POST \
              -H "Content-type: application/json" \
              --data "{\"text\":\"$ESCAPED_STALE\"}" \
              ${{ secrets.SLACK_WEBHOOK_URL }}
              
            echo "=== JIRA MONITOR COMPLETED SUCCESSFULLY ==="
            exit 0
          fi
          
          # Step 2: Process each ticket to check for external comments
          echo "Analyzing comments for $TICKET_COUNT tickets..."
          
          # Arrays to store filtered ticket lists
          NO_EXTERNAL_COMMENTS=()
          NO_EXTERNAL_COMMENTS_7DAYS=()
          
          # Process each ticket
          for TICKET_KEY in "${TICKET_KEYS[@]}"; do
            echo "Processing ticket: $TICKET_KEY"
            
            # Fetch comments for this ticket
            COMMENT_URL="${JIRA_BASE_URL}/rest/api/3/issue/${TICKET_KEY}/comment"
            COMMENT_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$COMMENT_URL")
            
            # Initialize flags
            HAS_EXTERNAL_COMMENT=false
            HAS_RECENT_EXTERNAL_COMMENT=false
            MOST_RECENT_EXTERNAL_DATE=""
            
            # Check if we can retrieve comments
            if [[ $(echo "$COMMENT_RESPONSE" | jq 'has("comments")') == "true" ]]; then
              COMMENTS=$(echo "$COMMENT_RESPONSE" | jq '.comments')
              COMMENT_COUNT=$(echo "$COMMENTS" | jq '. | length')
              
              if [ "$COMMENT_COUNT" -gt 0 ]; then
                # Process all comments to find external ones (jsdPublic: true)
                for (( k=0; k<COMMENT_COUNT; k++ )); do
                  COMMENT=$(echo "$COMMENTS" | jq ".[$k]")
                  
                  # Check if jsdPublic exists and is true (external comment)
                  if [[ $(echo "$COMMENT" | jq 'has("jsdPublic")') == "true" ]]; then
                    IS_PUBLIC=$(echo "$COMMENT" | jq -r '.jsdPublic')
                    if [[ "$IS_PUBLIC" == "true" ]]; then
                      HAS_EXTERNAL_COMMENT=true
                      COMMENT_DATE=$(echo "$COMMENT" | jq -r '.created')
                      
                      # Track the most recent external comment date
                      if [[ -z "$MOST_RECENT_EXTERNAL_DATE" || "$COMMENT_DATE" > "$MOST_RECENT_EXTERNAL_DATE" ]]; then
                        MOST_RECENT_EXTERNAL_DATE="$COMMENT_DATE"
                      fi
                    fi
                  fi
                done
                
                # If we found external comments, check if the most recent one is older than 7 days
                if [ "$HAS_EXTERNAL_COMMENT" = true ]; then
                  RECENT_TIMESTAMP=$(date -d "$MOST_RECENT_EXTERNAL_DATE" +%s)
                  CURRENT_TIMESTAMP=$(date +%s)
                  DAYS_SINCE_COMMENT=$(( (CURRENT_TIMESTAMP - RECENT_TIMESTAMP) / 86400 ))
                  
                  if [ "$DAYS_SINCE_COMMENT" -le 7 ]; then
                    HAS_RECENT_EXTERNAL_COMMENT=true
                  else
                    echo "  $TICKET_KEY - External comment is older than 7 days ($DAYS_SINCE_COMMENT days old)"
                    NO_EXTERNAL_COMMENTS_7DAYS+=("$TICKET_KEY")
                  fi
                else
                  echo "  $TICKET_KEY - No external comments found"
                  NO_EXTERNAL_COMMENTS+=("$TICKET_KEY")
                fi
              else
                echo "  $TICKET_KEY - No comments at all"
                NO_EXTERNAL_COMMENTS+=("$TICKET_KEY")
              fi
            else
              echo "  WARNING: Could not fetch comments for $TICKET_KEY"
            fi
          done
          
          # Step 3: Create CSV lists of ticket numbers for reporting
          NO_EXTERNAL_CSV=$(IFS=,; echo "${NO_EXTERNAL_COMMENTS[*]}")
          NO_RECENT_EXTERNAL_CSV=$(IFS=,; echo "${NO_EXTERNAL_COMMENTS_7DAYS[*]}")
          
          # Step 4: Create links to JQL queries for these ticket lists using issueKey format
          NO_EXTERNAL_COUNT=${#NO_EXTERNAL_COMMENTS[@]}
          NO_RECENT_EXTERNAL_COUNT=${#NO_EXTERNAL_COMMENTS_7DAYS[@]}
          
          if [ $NO_EXTERNAL_COUNT -gt 0 ]; then
            # Create a JQL query specifically for tickets with no external comments
            # Using issueKey instead of key for direct ticket lookup
            NO_EXT_JQL="issueKey in (${NO_EXTERNAL_CSV}) ORDER BY created DESC"
            NO_EXT_JQL_ENCODED=$(urlencode "$NO_EXT_JQL")
            NO_EXT_LINK="${JIRA_BROWSE_URL}${NO_EXT_JQL_ENCODED}"
            
            echo "JQL for tickets with no external comments: $NO_EXT_JQL"
          else
            NO_EXT_LINK=""
          fi
          
          if [ $NO_RECENT_EXTERNAL_COUNT -gt 0 ]; then
            # Create a JQL query for tickets with old external comments
            # Using issueKey instead of key for direct ticket lookup
            OLD_EXT_JQL="issueKey in (${NO_RECENT_EXTERNAL_CSV}) ORDER BY created DESC"
            OLD_EXT_JQL_ENCODED=$(urlencode "$OLD_EXT_JQL")
            OLD_EXT_LINK="${JIRA_BROWSE_URL}${OLD_EXT_JQL_ENCODED}"
            
            echo "JQL for tickets with old external comments: $OLD_EXT_JQL"
          else
            OLD_EXT_LINK=""
          fi
          
          # Step 5: Create Slack message with the results
          STALE_MESSAGE="*Stale Ticket Analysis for ${MEMBER}:*\n"
          STALE_MESSAGE="${STALE_MESSAGE}‚Ä¢ *Potentially Stale Tickets:* <${STALE_LINK}|${TICKET_COUNT} tickets> not updated in the last 7 days\n"
          
          # Add no external comments info
          STALE_MESSAGE="${STALE_MESSAGE}‚Ä¢ *Tickets With No External Comments:* "
          if [ $NO_EXTERNAL_COUNT -gt 0 ]; then
            STALE_MESSAGE="${STALE_MESSAGE}<${NO_EXT_LINK}|${NO_EXTERNAL_COUNT} tickets>\n"
            STALE_MESSAGE="${STALE_MESSAGE}  ‚Ü≥ Ticket Numbers: ${NO_EXTERNAL_CSV}\n"
          else
            STALE_MESSAGE="${STALE_MESSAGE}0 tickets\n"
          fi
          
          # Add old external comments info
          STALE_MESSAGE="${STALE_MESSAGE}‚Ä¢ *Tickets With Stale External Comments (>7 days):* "
          if [ $NO_RECENT_EXTERNAL_COUNT -gt 0 ]; then
            STALE_MESSAGE="${STALE_MESSAGE}<${OLD_EXT_LINK}|${NO_RECENT_EXTERNAL_COUNT} tickets>\n"
            STALE_MESSAGE="${STALE_MESSAGE}  ‚Ü≥ Ticket Numbers: ${NO_RECENT_EXTERNAL_CSV}\n"
          else
            STALE_MESSAGE="${STALE_MESSAGE}0 tickets\n"
          fi
          
          # Send to Slack
          echo "Sending stale ticket analysis to Slack..."
          ESCAPED_STALE=$(echo "$STALE_MESSAGE" | sed 's/"/\\"/g')
          curl -s -X POST \
            -H "Content-type: application/json" \
            --data "{\"text\":\"$ESCAPED_STALE\"}" \
            ${{ secrets.SLACK_WEBHOOK_URL }}
          
          echo "=== JIRA MONITOR COMPLETED SUCCESSFULLY ==="