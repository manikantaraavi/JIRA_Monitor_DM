name: jira-ticket-monitor

on:
  schedule:
    - cron: '30 4 * * 1-5'  # Fixed spacing: 10:00 AM AET / 4:30 AM IST on weekdays
  workflow_dispatch:
  push:
    paths:
      - '.github/workflows/jira-ticket-monitor.yml'

# Add concurrency control to help with queue issues
concurrency:
  group: jira-ticket-monitor
  cancel-in-progress: false

env:
  TZ: 'Asia/Kolkata'  # Set timezone to IST for the entire workflow

jobs:
  monitor-jira-tickets:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Increased timeout to handle stale ticket checking
    steps:
      # Add environment check step
      - name: Check environment
        run: |
          echo "Runner: $RUNNER_OS"
          echo "Free space:"
          df -h
          echo "Memory info:"
          free -h

      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 2
          
      - name: Send Workflow Update Notification
        if: github.event_name == 'push'
        run: |
          COMMIT_MSG=$(git log -1 --pretty=format:"%s")
          CHANGES=$(git diff --unified=0 HEAD^ HEAD .github/workflows/jira-ticket-monitor.yml | grep "^[+-]" | grep -v "^[+-][+-][+-]" | head -n 10)
          
          MESSAGE="üîÑ *WORKFLOW UPDATE DETECTED*\n\nüìù *Commit Message:*\n\`\`\`$COMMIT_MSG\`\`\`\n\nüë®‚Äçüíª *Changes Made:*\n\`\`\`\n$CHANGES\n...(more changes may not be shown)\n\`\`\`"
          
          curl -X POST \
            -H "Content-type: application/json" \
            --data "{\"text\": \"$MESSAGE\"}" \
            ${{ secrets.SLACK_WEBHOOK_URL }}
            
      - name: Monitor JIRA Tickets
        id: jira-monitor
        run: |
          # Debug: Print version info
          echo "===== RUNNING JIRA MONITOR SCRIPT ====="
          echo "Version: March 16, 2025 - Sateesh Only Test Version"
          
          # Create URL encoding function
          urlencode() {
            local string="${1}"
            local strlen=${#string}
            local encoded=""
            local pos c o
            
            for (( pos=0 ; pos<strlen ; pos++ )); do
              c=${string:$pos:1}
              case "$c" in
                [-_.~a-zA-Z0-9] ) o="${c}" ;;
                * ) printf -v o '%%%02x' "'$c"
              esac
              encoded+="${o}"
            done
            echo "${encoded}"
          }
          
          # JIRA Base URL for API and hyperlinks
          JIRA_BASE_URL="https://quantium.atlassian.net"
          JIRA_API_URL="${JIRA_BASE_URL}/rest/api/3/search"
          JIRA_BROWSE_URL="${JIRA_BASE_URL}/issues/?jql="
          
          # Jira API credentials
          AUTH_HEADER="Authorization: Basic ${{ secrets.JIRA_API_TOKEN }}"
          ACCEPT_HEADER="Accept: application/json"
          
          # Limited team members list - ONLY SATEESH
          TEAM_MEMBERS=(
            "Sateesh Gulivindala"
          )
          
          echo "Monitoring tickets for ${#TEAM_MEMBERS[@]} team members: ${TEAM_MEMBERS[0]}"
          
          # We've identified customfield_10065 as having the correct priority values
          PRIORITY_FIELD="customfield_10065"
          echo "Using PRIORITY_FIELD=$PRIORITY_FIELD for priorities"
          
          # Based on findings, define priorities as found in JIRA
          # These match the values in customfield_10065
          PRIORITY_NAMES=("1 - Critical" "2 - High" "3 - Medium" "4 - Low" "5 - Very Low")
          PRIORITY_SHORT=("P1" "P2" "P3" "P4" "P5")
          
          # Define emojis - used only in priority breakdown in summary
          EMOJIS=("üî¥" "üü†" "üü°" "üîµ" "‚ö™")
          
          # Age categories without emojis
          AGE_CATEGORIES=("‚â§7 days" "8-30 days" ">30 days")
          
          # Echo information about priority definitions
          echo "Using defined priorities:"
          for i in {0..4}; do
            echo "  ${PRIORITY_SHORT[$i]} = ${PRIORITY_NAMES[$i]}"
          done
          
          # Build team members clause for JQL - just Sateesh
          TEAM_MEMBERS_CLAUSE="assignee = \"${TEAM_MEMBERS[0]}\""
          
          # Variables for tracking tickets
          TOTAL_OPEN_TICKETS=0
          PRIORITY_COUNTS=()
          for i in {0..4}; do
            PRIORITY_COUNTS[$i]=0
          done
          UNDEFINED_PRIORITY_COUNT=0  # New counter for undefined priorities
          
          # Array to track stale tickets (no external comments for >7 days)
          STALE_TICKETS=()
          STALE_TICKET_COUNT=0
          
          # Time in IST and Sydney
          IST_TIME=$(date +"%I:%M %p IST")
          IST_DATE=$(date +"%d-%m-%Y")
          SYDNEY_TIME=$(TZ='Australia/Sydney' date +"%I:%M %p AEDT")
          
          # Build header part
          HEADER="üìä *JIRA Monitor (Test - Sateesh Only)*"
          
          # MESSAGE 1: Create the summary message
          # Create team-wide JQL for all tickets
          ALL_TEAM_JQL="(${TEAM_MEMBERS_CLAUSE}) AND status NOT IN (Closed, Resolved, Cancelled)"
          ALL_TEAM_LINK="${JIRA_BROWSE_URL}$(urlencode "$ALL_TEAM_JQL")"
          
          # Store team member data for workload sections
          MEMBER_DATA=()
          
          # Process each team member for total counts - Just Sateesh in this test
          for MEMBER in "${TEAM_MEMBERS[@]}"; do
            echo "üîç Fetching open tickets for: $MEMBER"
            
            # First query: All open tickets using the standard format
            ALL_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled)"
            ALL_JQL_ENCODED=$(urlencode "$ALL_JQL")
            ALL_URL="${JIRA_API_URL}?jql=${ALL_JQL_ENCODED}&maxResults=1000&fields=${PRIORITY_FIELD},summary,created,updated"
            ALL_LINK="${JIRA_BROWSE_URL}${ALL_JQL_ENCODED}"
            
            # Fetch all tickets with the priority field
            ALL_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$ALL_URL")
            
            # Extract total count
            TOTAL_COUNT=$(jq -r '.total' <<< "$ALL_RESPONSE")
            TOTAL_OPEN_TICKETS=$((TOTAL_OPEN_TICKETS + TOTAL_COUNT))
            
            MEMBER_PRIORITY_COUNTS=()
            for i in {0..4}; do
              MEMBER_PRIORITY_COUNTS[$i]=0
            done
            MEMBER_UNDEFINED_COUNT=0  # New counter for undefined priorities per member
            
            if [ "$TOTAL_COUNT" -gt 0 ]; then
              # Parse all tickets to count priorities
              ISSUES=$(jq '.issues' <<< "$ALL_RESPONSE")
              
              # Go through each ticket and examine its priority value
              ISSUE_COUNT=$(jq '. | length' <<< "$ISSUES")
              
              for (( j=0; j<ISSUE_COUNT; j++ )); do
                ISSUE=$(jq ".[$j]" <<< "$ISSUES")
                TICKET_KEY=$(jq -r '.key' <<< "$ISSUE")
                
                # Get the priority value from the nested JSON directly
                PRIORITY_VALUE=$(jq -r ".fields.\"$PRIORITY_FIELD\".value" <<< "$ISSUE")
                
                # Debug the priority value to help diagnose issues
                echo "  Ticket: $TICKET_KEY | Priority Value: '$PRIORITY_VALUE'"
                
                # Count based on the exact priority value pattern
                if [[ "$PRIORITY_VALUE" == "1 - Critical" ]]; then
                  MEMBER_PRIORITY_COUNTS[0]=$((MEMBER_PRIORITY_COUNTS[0] + 1))
                  PRIORITY_COUNTS[0]=$((PRIORITY_COUNTS[0] + 1))
                elif [[ "$PRIORITY_VALUE" == "2 - High" ]]; then
                  MEMBER_PRIORITY_COUNTS[1]=$((MEMBER_PRIORITY_COUNTS[1] + 1))
                  PRIORITY_COUNTS[1]=$((PRIORITY_COUNTS[1] + 1))
                elif [[ "$PRIORITY_VALUE" == "3 - Medium" ]]; then
                  MEMBER_PRIORITY_COUNTS[2]=$((MEMBER_PRIORITY_COUNTS[2] + 1))
                  PRIORITY_COUNTS[2]=$((PRIORITY_COUNTS[2] + 1))
                elif [[ "$PRIORITY_VALUE" == "4 - Low" ]]; then
                  MEMBER_PRIORITY_COUNTS[3]=$((MEMBER_PRIORITY_COUNTS[3] + 1))
                  PRIORITY_COUNTS[3]=$((PRIORITY_COUNTS[3] + 1))
                elif [[ "$PRIORITY_VALUE" == "5 - Very Low" ]]; then
                  MEMBER_PRIORITY_COUNTS[4]=$((MEMBER_PRIORITY_COUNTS[4] + 1))
                  PRIORITY_COUNTS[4]=$((PRIORITY_COUNTS[4] + 1))
                else
                  # Default to P3 if unknown, but also track undefined separately
                  MEMBER_PRIORITY_COUNTS[2]=$((MEMBER_PRIORITY_COUNTS[2] + 1))
                  PRIORITY_COUNTS[2]=$((PRIORITY_COUNTS[2] + 1))
                  
                  # Increment undefined counters
                  MEMBER_UNDEFINED_COUNT=$((MEMBER_UNDEFINED_COUNT + 1))
                  UNDEFINED_PRIORITY_COUNT=$((UNDEFINED_PRIORITY_COUNT + 1))
                  
                  echo "  NOTE: Ticket with undefined priority counted as P3: $TICKET_KEY"
                fi
                
                # Check for stale tickets (no external comments for >7 days)
                # First, fetch comments for this ticket
                COMMENT_URL="${JIRA_BASE_URL}/rest/api/3/issue/${TICKET_KEY}/comment"
                COMMENT_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$COMMENT_URL")
                
                # Extract information for checking staleness
                TICKET_SUMMARY=$(jq -r '.fields.summary' <<< "$ISSUE")
                CREATED_DATE=$(jq -r '.fields.created' <<< "$ISSUE")
                
                # Check if we can retrieve comments
                if [[ $(jq 'has("comments")' <<< "$COMMENT_RESPONSE") == "true" ]]; then
                  COMMENTS=$(jq '.comments' <<< "$COMMENT_RESPONSE")
                  COMMENT_COUNT=$(jq '. | length' <<< "$COMMENTS")
                  
                  # Default to no external comments found
                  FOUND_EXTERNAL_COMMENT=false
                  MOST_RECENT_COMMENT_DATE=""
                  
                  if [ "$COMMENT_COUNT" -gt 0 ]; then
                    # Process all comments to find external ones (jsdPublic: true)
                    for (( k=0; k<COMMENT_COUNT; k++ )); do
                      COMMENT=$(jq ".[$k]" <<< "$COMMENTS")
                      # Check if jsdPublic exists and is true
                      if [[ $(jq 'has("jsdPublic")' <<< "$COMMENT") == "true" ]]; then
                        IS_PUBLIC=$(jq -r '.jsdPublic' <<< "$COMMENT")
                        if [[ "$IS_PUBLIC" == "true" ]]; then
                          FOUND_EXTERNAL_COMMENT=true
                          COMMENT_DATE=$(jq -r '.created' <<< "$COMMENT")
                          
                          # Track the most recent external comment date
                          if [[ -z "$MOST_RECENT_COMMENT_DATE" || "$COMMENT_DATE" > "$MOST_RECENT_COMMENT_DATE" ]]; then
                            MOST_RECENT_COMMENT_DATE="$COMMENT_DATE"
                          fi
                        fi
                      fi
                    done
                  fi
                  
                  # Check if there are no external comments or if the most recent one is older than 7 days
                  if [ "$FOUND_EXTERNAL_COMMENT" = false ]; then
                    # No external comments at all - check when the ticket was created
                    CREATED_TIMESTAMP=$(date -d "$CREATED_DATE" +%s)
                    CURRENT_TIMESTAMP=$(date +%s)
                    DAYS_SINCE_CREATION=$(( (CURRENT_TIMESTAMP - CREATED_TIMESTAMP) / 86400 ))
                    
                    if [ "$DAYS_SINCE_CREATION" -gt 7 ]; then
                      # Ticket is older than 7 days with no external comments
                      echo "  STALE: $TICKET_KEY - No external comments since creation ($DAYS_SINCE_CREATION days ago)"
                      STALE_TICKETS+=("$TICKET_KEY,No external comments,$TICKET_SUMMARY,$MEMBER")
                      STALE_TICKET_COUNT=$((STALE_TICKET_COUNT + 1))
                    fi
                  elif [ -n "$MOST_RECENT_COMMENT_DATE" ]; then
                    # Check how old the most recent external comment is
                    RECENT_TIMESTAMP=$(date -d "$MOST_RECENT_COMMENT_DATE" +%s)
                    CURRENT_TIMESTAMP=$(date +%s)
                    DAYS_SINCE_COMMENT=$(( (CURRENT_TIMESTAMP - RECENT_TIMESTAMP) / 86400 ))
                    
                    if [ "$DAYS_SINCE_COMMENT" -gt 7 ]; then
                      # Most recent external comment is older than 7 days
                      FORMATTED_DATE=$(date -d "$MOST_RECENT_COMMENT_DATE" "+%Y-%m-%d")
                      echo "  STALE: $TICKET_KEY - Last external comment was $DAYS_SINCE_COMMENT days ago"
                      STALE_TICKETS+=("$TICKET_KEY,$FORMATTED_DATE,$TICKET_SUMMARY,$MEMBER")
                      STALE_TICKET_COUNT=$((STALE_TICKET_COUNT + 1))
                    fi
                  fi
                else
                  echo "  WARNING: Could not fetch comments for $TICKET_KEY"
                fi
              done
              
              # Create JQL queries for each priority - simplified for test version
              PRIORITY_LINKS=()
              
              # P1 - Critical Priority
              PRIORITY_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND \"Priority (SD)[Dropdown]\" = \"1 - Critical\""
              PRIORITY_LINKS[0]="${JIRA_BROWSE_URL}$(urlencode "$PRIORITY_JQL")"
              
              # P2 - High Priority
              PRIORITY_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND \"Priority (SD)[Dropdown]\" = \"2 - High\""
              PRIORITY_LINKS[1]="${JIRA_BROWSE_URL}$(urlencode "$PRIORITY_JQL")"
              
              # P3 - Medium Priority
              PRIORITY_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND \"Priority (SD)[Dropdown]\" = \"3 - Medium\""
              PRIORITY_LINKS[2]="${JIRA_BROWSE_URL}$(urlencode "$PRIORITY_JQL")"
              
              # P4 - Low Priority
              PRIORITY_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND \"Priority (SD)[Dropdown]\" = \"4 - Low\""
              PRIORITY_LINKS[3]="${JIRA_BROWSE_URL}$(urlencode "$PRIORITY_JQL")"
              
              # P5 - Very Low Priority
              PRIORITY_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND \"Priority (SD)[Dropdown]\" = \"5 - Very Low\""
              PRIORITY_LINKS[4]="${JIRA_BROWSE_URL}$(urlencode "$PRIORITY_JQL")"
              
              # Format age breakdown - simplified for test
              WEEK_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND created >= -7d"
              WEEK_JQL_ENCODED=$(urlencode "$WEEK_JQL")
              WEEK_URL="${JIRA_API_URL}?jql=${WEEK_JQL_ENCODED}&maxResults=1000"
              WEEK_LINK="${JIRA_BROWSE_URL}${WEEK_JQL_ENCODED}"
              WEEK_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$WEEK_URL")
              WEEK_COUNT=$(jq -r '.total' <<< "$WEEK_RESPONSE")
              
              MONTH_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND created < -7d AND created >= -30d"
              MONTH_JQL_ENCODED=$(urlencode "$MONTH_JQL")
              MONTH_URL="${JIRA_API_URL}?jql=${MONTH_JQL_ENCODED}&maxResults=1000"
              MONTH_LINK="${JIRA_BROWSE_URL}${MONTH_JQL_ENCODED}"
              MONTH_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$MONTH_URL")
              MONTH_COUNT=$(jq -r '.total' <<< "$MONTH_RESPONSE")
              
              OLDER_JQL="assignee = \"$MEMBER\" AND status NOT IN (Closed, Resolved, Cancelled) AND created < -30d"
              OLDER_JQL_ENCODED=$(urlencode "$OLDER_JQL")
              OLDER_URL="${JIRA_API_URL}?jql=${OLDER_JQL_ENCODED}&maxResults=1000"
              OLDER_LINK="${JIRA_BROWSE_URL}${OLDER_JQL_ENCODED}"
              OLDER_RESPONSE=$(curl -s -H "$AUTH_HEADER" -H "$ACCEPT_HEADER" "$OLDER_URL")
              OLDER_COUNT=$(jq -r '.total' <<< "$OLDER_RESPONSE")
              
              # Format message for this team member - no emojis in both priority and age
              MEMBER_MESSAGE="‚Ä¢ *${MEMBER}:* <${ALL_LINK}|${TOTAL_COUNT}>"
              MEMBER_MESSAGE="${MEMBER_MESSAGE}\n  ‚Ü≥ Priority: "
              
              for i in {0..4}; do
                if [ $i -gt 0 ]; then
                  MEMBER_MESSAGE="${MEMBER_MESSAGE} | "
                fi
                
                if [ ${MEMBER_PRIORITY_COUNTS[$i]} -gt 0 ]; then
                  MEMBER_MESSAGE="${MEMBER_MESSAGE}${PRIORITY_SHORT[$i]}: <${PRIORITY_LINKS[$i]}|${MEMBER_PRIORITY_COUNTS[$i]}>"
                else
                  MEMBER_MESSAGE="${MEMBER_MESSAGE}${PRIORITY_SHORT[$i]}: ${MEMBER_PRIORITY_COUNTS[$i]}"
                fi
              done
              
              # Add age breakdown to the message - no emojis
              MEMBER_MESSAGE="${MEMBER_MESSAGE}\n  ‚Ü≥ Age: "
              
              if [ "$WEEK_COUNT" -gt 0 ]; then
                MEMBER_MESSAGE="${MEMBER_MESSAGE}<${WEEK_LINK}|${WEEK_COUNT}> (‚â§7d)"
              else
                MEMBER_MESSAGE="${MEMBER_MESSAGE}${WEEK_COUNT} (‚â§7d)"
              fi
              
              MEMBER_MESSAGE="${MEMBER_MESSAGE} | "
              
              if [ "$MONTH_COUNT" -gt 0 ]; then
                MEMBER_MESSAGE="${MEMBER_MESSAGE}<${MONTH_LINK}|${MONTH_COUNT}> (8-30d)"
              else
                MEMBER_MESSAGE="${MEMBER_MESSAGE}${MONTH_COUNT} (8-30d)"
              fi
              
              MEMBER_MESSAGE="${MEMBER_MESSAGE} | "
              
              if [ "$OLDER_COUNT" -gt 0 ]; then
                MEMBER_MESSAGE="${MEMBER_MESSAGE}<${OLDER_LINK}|${OLDER_COUNT}> (>30d)"
              else
                MEMBER_MESSAGE="${MEMBER_MESSAGE}${OLDER_COUNT} (>30d)"
              fi
            else
              # No tickets for this member
              MEMBER_MESSAGE="‚Ä¢ *${MEMBER}:* 0"
            fi
            
            # Store in array for grouping later
            MEMBER_DATA+=("$MEMBER_MESSAGE")
          done
          
          # Create team-wide JQL for priority filters
          TEAM_PRIORITY_LINKS=()
          
          # P1 - Critical Priority
          TEAM_PRIORITY_JQL="(${TEAM_MEMBERS_CLAUSE}) AND status NOT IN (Closed, Resolved, Cancelled) AND \"Priority (SD)[Dropdown]\" = \"1 - Critical\""
          TEAM_PRIORITY_LINKS[0]="${JIRA_BROWSE_URL}$(urlencode "$TEAM_PRIORITY_JQL")"
          
          # P2 - High Priority
          TEAM_PRIORITY_JQL="(${TEAM_MEMBERS_CLAUSE}) AND status NOT IN (Closed, Resolved, Cancelled) AND \"Priority (SD)[Dropdown]\" = \"2 - High\""
          TEAM_PRIORITY_LINKS[1]="${JIRA_BROWSE_URL}$(urlencode "$TEAM_PRIORITY_JQL")"
          
          # P3 - Medium Priority
          TEAM_PRIORITY_JQL="(${TEAM_MEMBERS_CLAUSE}) AND status NOT IN (Closed, Resolved, Cancelled) AND \"Priority (SD)[Dropdown]\" = \"3 - Medium\""
          TEAM_PRIORITY_LINKS[2]="${JIRA_BROWSE_URL}$(urlencode "$TEAM_PRIORITY_JQL")"
          
          # P4 - Low Priority
          TEAM_PRIORITY_JQL="(${TEAM_MEMBERS_CLAUSE}) AND status NOT IN (Closed, Resolved, Cancelled) AND \"Priority (SD)[Dropdown]\" = \"4 - Low\""
          TEAM_PRIORITY_LINKS[3]="${JIRA_BROWSE_URL}$(urlencode "$TEAM_PRIORITY_JQL")"
          
          # P5 - Very Low Priority
          TEAM_PRIORITY_JQL="(${TEAM_MEMBERS_CLAUSE}) AND status NOT IN (Closed, Resolved, Cancelled) AND \"Priority (SD)[Dropdown]\" = \"5 - Very Low\""
          TEAM_PRIORITY_LINKS[4]="${JIRA_BROWSE_URL}$(urlencode "$TEAM_PRIORITY_JQL")"
          
          # Fix the age legend hyperlinks
          TEAM_WEEK_JQL="(${TEAM_MEMBERS_CLAUSE}) AND status NOT IN (Closed, Resolved, Cancelled) AND created >= -7d"
          TEAM_WEEK_LINK="${JIRA_BROWSE_URL}$(urlencode "$TEAM_WEEK_JQL")"
          
          TEAM_MONTH_JQL="(${TEAM_MEMBERS_CLAUSE}) AND status NOT IN (Closed, Resolved, Cancelled) AND created < -7d AND created >= -30d"
          TEAM_MONTH_LINK="${JIRA_BROWSE_URL}$(urlencode "$TEAM_MONTH_JQL")"
          
          TEAM_OLDER_JQL="(${TEAM_MEMBERS_CLAUSE}) AND status NOT IN (Closed, Resolved, Cancelled) AND created < -30d"
          TEAM_OLDER_LINK="${JIRA_BROWSE_URL}$(urlencode "$TEAM_OLDER_JQL")"
          
          # Build the summary message (MESSAGE 1)
          SUMMARY_MESSAGE="$HEADER\n\n*Summary:*"
          
          # Plain text summary with hyperlink for total tickets and time zones
          SUMMARY_MESSAGE="$SUMMARY_MESSAGE\n‚Ä¢ *Team JIRA Status Update* ($SYDNEY_TIME / $IST_TIME)"
          SUMMARY_MESSAGE="$SUMMARY_MESSAGE\n‚Ä¢ *Open Tickets:* <${ALL_TEAM_LINK}|${TOTAL_OPEN_TICKETS}>"
          
          # Add priority breakdown with hyperlinks to specific priority searches - NO emojis
          PRIORITY_SUMMARY="\n‚Ä¢ *Priority Breakdown:* "
          for i in {0..4}; do
            if [ $i -gt 0 ]; then
              PRIORITY_SUMMARY="${PRIORITY_SUMMARY} | "
            fi
            if [ ${PRIORITY_COUNTS[$i]} -gt 0 ]; then
              PRIORITY_SUMMARY="${PRIORITY_SUMMARY}${PRIORITY_SHORT[$i]}: <${TEAM_PRIORITY_LINKS[$i]}|${PRIORITY_COUNTS[$i]}>"
            else
              PRIORITY_SUMMARY="${PRIORITY_SUMMARY}${PRIORITY_SHORT[$i]}: ${PRIORITY_COUNTS[$i]}"
            fi
          done
          
          SUMMARY_MESSAGE="$SUMMARY_MESSAGE$PRIORITY_SUMMARY"
          
          # Create age legend matching the exact format from queue-monitor.yml but without colors
          AGE_LEGEND="üìä *Legend:* <${TEAM_WEEK_LINK}|‚â§7 days> | <${TEAM_MONTH_LINK}|8-30 days> | <${TEAM_OLDER_LINK}|30+ days>"
          
          # Create one group for legend and notes
          LEGEND_GROUP="$AGE_LEGEND"
          
          # Add note about undefined priorities to the same group
          if [ ${UNDEFINED_PRIORITY_COUNT} -gt 0 ]; then
            LEGEND_GROUP="$LEGEND_GROUP\n\n‚ö†Ô∏è *Note:* Undefined priorities (${UNDEFINED_PRIORITY_COUNT}) are counted under P3."
          fi
          
          # Add the grouped legend to summary message
          SUMMARY_MESSAGE="$SUMMARY_MESSAGE\n\n$LEGEND_GROUP"
          
          echo "Sending summary message to Slack..."
          
          # Send the summary message first
          ESCAPED_SUMMARY=$(echo "$SUMMARY_MESSAGE" | sed 's/"/\\"/g')
          curl -s -X POST \
               -H "Content-type: application/json" \
               --data "{\"text\":\"$ESCAPED_SUMMARY\"}" \
               ${{ secrets.SLACK_WEBHOOK_URL }}
          
          # Sleep to ensure messages are sent in order
          sleep 1
          
          # Prepare workload messages - simplified for test
          WORKLOAD_MESSAGE="*Team Workload:*"
          
          for (( i=0; i<${#MEMBER_DATA[@]}; i++ )); do
            # Add member data directly (no batching needed for just one member)
            WORKLOAD_MESSAGE="$WORKLOAD_MESSAGE\n${MEMBER_DATA[$i]}"
          done
          
          # Send workload data
          echo "Sending workload message to Slack..."
          ESCAPED_WORKLOAD=$(echo "$WORKLOAD_MESSAGE" | sed 's/"/\\"/g')
          curl -s -X POST \
               -H "Content-type: application/json" \
               --data "{\"text\":\"$ESCAPED_WORKLOAD\"}" \
               ${{ secrets.SLACK_WEBHOOK_URL }}
          
          # Process stale tickets if any found
          if [ $STALE_TICKET_COUNT -gt 0 ]; then
            # Create stale tickets message
            STALE_MESSAGE="*Stale Tickets (No external comments for >7 days):*\n"
            STALE_MESSAGE="${STALE_MESSAGE}‚Ä¢ Found $STALE_TICKET_COUNT tickets with no external comments for over 7 days\n"
            
            if [ $STALE_TICKET_COUNT -le 5 ]; then
              # Display tickets directly in Slack with hyperlinks
              for ticket_info in "${STALE_TICKETS[@]}"; do
                # Parse CSV-format ticket info
                IFS=',' read -r TICKET_KEY LAST_COMMENT TICKET_SUMMARY TICKET_ASSIGNEE <<< "$ticket_info"
                # Remove quotes from summary if any
                TICKET_SUMMARY=$(echo "$TICKET_SUMMARY" | sed 's/"//g')
                
                # Create ticket link
                TICKET_LINK="${JIRA_BASE_URL}/browse/${TICKET_KEY}"
                
                # Add to message
                if [[ "$LAST_COMMENT" == "No external comments" ]]; then
                  STALE_MESSAGE="${STALE_MESSAGE}‚Ä¢ <${TICKET_LINK}|${TICKET_KEY}> - ${TICKET_SUMMARY} (${LAST_COMMENT}, Assigned to: ${TICKET_ASSIGNEE})\n"
                else
                  STALE_MESSAGE="${STALE_MESSAGE}‚Ä¢ <${TICKET_LINK}|${TICKET_KEY}> - ${TICKET_SUMMARY} (Last external comment: ${LAST_COMMENT}, Assigned to: ${TICKET_ASSIGNEE})\n"
                fi
              done
              
              # Send stale tickets message
              echo "Sending stale tickets list to Slack..."
              ESCAPED_STALE=$(echo "$STALE_MESSAGE" | sed 's/"/\\"/g')
              curl -s -X POST \
                   -H "Content-type: application/json" \
                   --data "{\"text\":\"$ESCAPED_STALE\"}" \
                   ${{ secrets.SLACK_WEBHOOK_URL }}
            else
              # Create a CSV file for more than 5 tickets
              echo "Creating CSV file for $STALE_TICKET_COUNT stale tickets..."
              
              # Create CSV file
              CSV_FILE="stale_tickets_$(date +%Y%m%d).csv"
              echo "Ticket,Last External Comment,Summary,Assigned To" > "$CSV_FILE"
              
              for ticket_info in "${STALE_TICKETS[@]}"; do
                echo "$ticket_info" >> "$CSV_FILE"
              done
              
              # Add CSV file info to message
              STALE_MESSAGE="${STALE_MESSAGE}‚Ä¢ CSV file with details for all $STALE_TICKET_COUNT stale tickets is attached.\n"
              STALE_MESSAGE="${STALE_MESSAGE}‚Ä¢ CSV contains: ticket number, last external comment date, subject, and assignee."
              
              # Send message about CSV file without file upload for this test
              echo "Sending stale tickets message to Slack..."
              ESCAPED_STALE=$(echo "$STALE_MESSAGE" | sed 's/"/\\"/g')
              curl -s -X POST \
                   -H "Content-type: application/json" \
                   --data "{\"text\":\"$ESCAPED_STALE\"}" \
                   ${{ secrets.SLACK_WEBHOOK_URL }}
              
              # Test version doesn't try file upload to reduce complexity
              echo "TEST MODE: CSV file created but not uploaded to Slack"
              cat "$CSV_FILE" | head -5
            fi
          else
            echo "No stale tickets found"
          fi
          
          echo "=== JIRA MONITOR COMPLETED SUCCESSFULLY ==="